package controller;

import controller.multiobjectives.MultiObjectiveRunningWindowController;
import controller.singleobjectives.SingleObjectiveRunningWindowController;
import controller.utils.ProblemMenuConfiguration;
import exception.InputException;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Pane;
import javafx.stage.FileChooser;
import javafx.stage.Window;
import model.epanet.element.Network;
import model.epanet.io.InpParser;
import model.metaheuristic.algorithm.Algorithm;
import model.metaheuristic.experiment.Experiment;
import model.metaheuristic.problem.Problem;
import registrable.MultiObjectiveRegistrable;
import registrable.SingleObjectiveRegistrable;
import view.ElementViewer;
import view.NetworkComponent;
import view.utils.CustomDialogs;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;

/**
 * The controller of the main window view.
 * 
 * From this class is opened the RunningWindow when the problem is selected in
 * menu item.
 *
 */
public class MainWindowController implements Initializable {
	@FXML
	private BorderPane root;

	/**
	 * The SplitPane where the NetworkComponent and the ElementViewer are
	 */
	@FXML
	private SplitPane splitPane;

	/**
	 * Is a pane that envolve networkComponent. Is used to resize the
	 * networkComponent automatically when screen size change
	 */
	@FXML
	private Pane canvasWrapper;

	/**
	 * Is the section where the network is painted
	 */
	@FXML
	private NetworkComponent networkComponent;

	/**
	 * It is a pane that show the element of network
	 */
	@FXML
	private ElementViewer elementViewer;

	/**
	 * Is the option of menu for singleobjectives problems. It is filled using reflection through
	 * ProblemRegistrar.
	 */
	@FXML
	private Menu singleobjectiveMenu;
	/**
	 * Is the option of menu for multiobjectives problem. It is filled using reflection through
	 * ProblemRegistrar.
	 */
	@FXML
	private Menu multiobjectiveMenu;
	/**
	 * Run a simulation with default network configuration
	 */
	@FXML
	private Button runButton;

	/**
	 * The tabpane
	 */
	@FXML
	private TabPane tabPane;
	/**
	 * Save the result tab
	 */
	@FXML
	private Button saveTableButton;
	/**
	 * Save as inp the selected items in result tab
	 */
	@FXML
	private Button saveSelectedAsINPButton;

	private Window window;
	private File inpFile;
	private final BooleanProperty isNetworkLoaded;
	private Network network;

	public MainWindowController() {
		this.isNetworkLoaded = new SimpleBooleanProperty(false);

	}

	@Override
	public void initialize(URL location, ResourceBundle resources) {
		// Register the menu item problem to problem menu and add the listener to it
		// menuitem to show a interface,
		ProblemMenuConfiguration problemRegistrar = new ProblemMenuConfiguration();
		problemRegistrar.addSingleObjectiveProblems(this.singleobjectiveMenu, this::runAlgorithm);
		problemRegistrar.addMultiObjectiveProblems(this.multiobjectiveMenu, this::runExperiment);

		// disable problem menu until a network is loaded
		this.singleobjectiveMenu.disableProperty().bind(isNetworkLoaded.not());
		this.multiobjectiveMenu.disableProperty().bind(isNetworkLoaded.not());
		this.runButton.disableProperty().bind(isNetworkLoaded.not());

		networkComponent.selectedProperty().bindBidirectional(elementViewer.selectedProperty());

		// Configure tabpane behaviour
		this.networkTab.selectedProperty().addListener((observable, oldValue, newValue) -> {
			if (newValue){ // clean bind and set property when default tab "network" is selected
				this.saveTableButton.setDisable(true);
				this.saveSelectedAsINPButton.disableProperty().unbind();
				this.saveSelectedAsINPButton.setDisable(true);
				this.saveSelectedAsINPButton.setOnAction(null);
				this.saveTableButton.setOnAction(null);
			}
		});
	}

	/**
	 * @param window the windows
	 * 
	 */
	public void setWindow(Window window) {
		this.window = window;
	}

	/**
	 * Handler from event generated by FXML file
	 */
	@FXML
	private void openOnAction() {
		FileChooser fileChooser = new FileChooser();
		fileChooser.setTitle("Open");
		fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter("INP file", "*.inp"));
		File file = fileChooser.showOpenDialog(this.window);
		if (file != null) {
			this.inpFile = file;
			loadNetwork(this.inpFile);

		}
	}

	/**
	 * Load the network
	 * 
	 * @param file the file
	 */
	private void loadNetwork(File file) {
		this.network = null;
		InpParser parse = new InpParser();

		try {
			this.network = new Network();
			parse.parse(this.network, file.getAbsolutePath());
			// If the network was loaded so show it
			if (!this.network.isEmpty()) {
				// draw network
				networkComponent.drawNetwork(this.network);
				// fill the viewer of the element network
				elementViewer.setNetwork(this.network);
				isNetworkLoaded.set(true);
			}
		} catch (IOException | InputException e) {
			CustomDialogs.showExceptionDialog("Error", "Error loading the network", "The network can't be loaded", e);
		}

	}

	/**
	 * Run the algorithm.<br>
	 * <br>
	 * 
	 * <br>
	 * <br>
	 * <strong>Notes:</strong> <br>
	 * This method is called by ConfigurationDynamicWindow when the algorithm is
	 * successfully created. When this method is executed open a RunningDialog that
	 * show the progress of execution of algorithm.
	 * 
	 * @param registrableProblem the factory of algorithm for a problem
	 */
	private void runAlgorithm(SingleObjectiveRegistrable registrableProblem) {
		String path = null;
		if (this.inpFile != null) {
			path = this.inpFile.getAbsolutePath();
		}
		Algorithm<?> algorithm = null;
		try {
			algorithm = registrableProblem.build(path);
		} catch (Exception e) {
			CustomDialogs.showExceptionDialog("Error", "Error in the creation of the algorithm",
					"The algorithm can't be created", e);
		}
		if (algorithm != null) {
			Problem<?> problem = registrableProblem.getProblem();
			SingleObjectiveRunningWindowController runningDialogController = new SingleObjectiveRunningWindowController(algorithm, problem,
					this.network, this::createResultTab);
			runningDialogController.showWindowAndRunAlgorithm();
		}

	}
	
	/**
	 * Run the experiment.<br>
	 * <br>
	 * 
	 * <br>
	 * <br>
	 * <strong>Notes:</strong> <br>
	 * This method is called by ConfigurationDynamicWindow when the experiment is
	 * successfully created. When this method is executed open a RunningDialog that
	 * show the progress of execution of algorithm.
	 * 
	 * @param registrableProblem the factory of algorithm for a problem
	 */
	private void runExperiment(MultiObjectiveRegistrable registrableProblem) {
		String path = null;
		if (this.inpFile != null) {
			path = this.inpFile.getAbsolutePath();
		}
		Experiment<?> experiment = null;
		try {
			experiment = registrableProblem.build(path);
		} catch (Exception e) {
			CustomDialogs.showExceptionDialog("Error", "Error in the creation of the experiment",
					"The algorithm can't be created", e);
		}
		if (experiment != null) {
			Problem<?> problem = registrableProblem.getProblem();
			MultiObjectiveRunningWindowController runningDialogController = new MultiObjectiveRunningWindowController(experiment, problem,
					this.network, this::createResultTab);
			runningDialogController.showWindowAndRunAlgorithm();
		}
	}

	private int resultCount = 0;
	/**
	 * Create a new result tab
	 * @param resultController the result controller
	 */
	private void createResultTab(ResultController resultController){
		Tab tab = new Tab("Result " + resultCount++, resultController.getNode());
		tab.setOnSelectionChanged(event -> {
			if (tab.selectedProperty().getValue()){ // add bind when select the tab
				this.saveTableButton.setDisable(false);
				this.saveSelectedAsINPButton.disableProperty().bind(resultController.hasSelectedItemProperty().not());
				//save the selected items
				this.saveSelectedAsINPButton.setOnAction(event1 -> {
					resultController.saveSelectedItemAsINP();
				});
				//save the table
				this.saveTableButton.setOnAction(event1 -> resultController.saveTable());
			}
		});

		tab.setOnClosed(event -> { // remove the bind when switch tab
			tab.setOnSelectionChanged(null);
			tab.setOnClosed(null);
		});
		this.tabPane.getTabs().addAll(tab);
		this.tabPane.getSelectionModel().select(tab);
	}

	/**
	 * The network tab. This is the tab by default and you must not close it.
	 */
	@FXML
	private Tab networkTab;
}
